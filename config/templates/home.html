<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Include the CesiumJS JavaScript and CSS files -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.107.1/Build/Cesium/Cesium.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.0.0/satellite.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
  <link rel="shortcut icon" href="#">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.107.1/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
</head>
<body>

  <div class="navbar">
    <ul class="nav-list">
        <li class="logo"><h2> <a href="{% url 'list_view' %}">satTrack ðŸª¨</a> </h1></li>
        <li>contact us</li>
        <li>search for satellite</li>
    </ul>
</div>
<div class="main-block">
    <div id="cesiumContainer"></div>
    <table class="t1">
        <tr>
            <td>NORAD ID:</td> <td>{{ satellite.norad_id }}</td>
        </tr>
        <tr>
            <td>UTC:</td>  <td id="utc">--</td>
        </tr>
        <tr>
            <td>LATITUDE:</td> <td id="lat">--</td>
        </tr>
        <tr>
            <td>LONGITUDE</td> <td id="lon">--</td>
        </tr>
        <tr>
            <td>ALTITUDE [km]:</td> <td  id="h">--</td>
        </tr>
        <tr>
            <td>SPEED [km/s]:</td> <td id="speed">--</td>
        </tr>
        <tr>
            <td>AZIMUTH:</td> <td id="az">--</td>
        </tr>
        <tr>
            <td>ELEVATION:</td> <td id="ele">--</td>
        </tr>
        <tr>
            <td>RIGHT ASCENSION:</td> <td id="ra">--</td>
        </tr>
        <tr>
          <td>DECLINATION:</td> <td id="dec">--</td>
        </tr>
    </table>
</div>
<div class="sat-details">
    <div class="sat-name">{{ satellite.name }}</div>
    <div class="description">{{ satellite.description }}</div>
    <table class="t2">
    <tr>
        <td>Satellite Name</td>
        <td>{{ satellite.name }}</td>
    </tr>
    <tr>
        <td>Status</td>
        <td>IN ORBIT</td>
    </tr>
    <tr>
        <td>Orbit</td>
        <td>--</td>
    </tr>
    <tr>
        <td>Launch Year</td>
        <td>{{ data.launch_year }}</td>
    </tr>
    <tr>
        <td>Life</td>
        <td>--</td>
    </tr>
    <tr>
        <td>Swath</td>
        <td>{{ sensor.swath }}</td>
    </tr>
    <tr>
        <td>Inclination</td>
        <td>{{ data.inclination }}</td>
    </tr>
    <tr>
        <td>Eccentricity</td>
        <td>{{ data.eccentricity }}</td>
    </tr>
    <tr>
        <td>Semi Major Axis</td>
        <td>{{ data.semi_major_axis }}</td>
    </tr>
    <tr>
        <td>Inclination</td>
        <td>{{ data.inclination }}</td>
    </tr>
    <tr>
        <td>Period</td>
        <td>{{ data.period }}</td>
    </tr>
    
    </table>
    <h4>TLE: </h4>
    <div>{{ data.L1|safe }}</div>
    <div>{{ data.L2|safe }}</div>
    <div>Last TLE update Date: {{ satellite.last_tle_update }}</div>
</div>
<button onclick="getLocation();">Get My Location</button>

  
  <script type="module">
    
    // convert radians to degrees
    function r2d(radians, n) {
      const num = radians * (180 / Math.PI);
      return Math.round(num * Math.pow(10, n)) / Math.pow(10, n)
    }

    // fetch live data from server
    function get_live_data() {
      console.log(cur_loc.lat)
      const div_data_lat = document.getElementById('lat');
      const div_data_lon = document.getElementById('lon');
      const div_data_height = document.getElementById('h');
      const div_data_time = document.getElementById('utc');
      const div_data_azimuth = document.getElementById('az');
      const div_data_elevation = document.getElementById('ele');
      const div_data_ra = document.getElementById('ra');
      const div_data_dec = document.getElementById('dec');
      const div_data_speed = document.getElementById('speed');
      var ps = viewer.entities.add({
        position: new Cesium.Cartesian3.fromDegrees(cur_loc.lon,cur_loc.lat ),
        point: {
          pixelSize: 6,
          color: Cesium.Color.RED,
        }
      });
      $.ajax({
        url: "{% url 'data' satellite.norad_id %}",
        type: "GET",
        dataType: "json",
        data: {"cur_loc_lat": cur_loc.lat, "cur_loc_lon": cur_loc.lon},
        success: (data) => {
          div_data_lat.innerHTML = `${data.context.lat}`;
          div_data_lon.innerHTML = `${data.context.lon}`;
          div_data_height.innerHTML = `${data.context.height}`;
          div_data_time.innerHTML = `${data.context.time}`;
          div_data_azimuth.innerHTML = `${data.context.azimuth}`;
          div_data_elevation.innerHTML = `${data.context.elevation}`;
          div_data_ra.innerHTML = `${data.context.ra}`;
          div_data_dec.innerHTML = `${data.context.dec}`;
          div_data_speed.innerHTML =  `${data.context.speed}`;
          // console.log(data.context);
        },
        error: (error) => {
          console.log(error);
        }
      });

    }
    

    // fetch data over timeline
    function get_data_buffer() {
      let data_readings;
      
      $.ajax({
        url: "{% url 'databuffer' satellite.norad_id %}",
        type: "GET",
        
        dataType: "json",
        async:false,
        success: (data) => {
          data_readings= data.context;      
        },
        error: (error) => {
          console.log(error);
        }
      });
      return data_readings
    }

    // finding the current location
    var cur_loc={};
    //successCallback
    function success(position){
      cur_loc.lat = position.coords.latitude;
      cur_loc.lon = position.coords.longitude;
    }
    //failureCallback
    function failure(position){
      cur_loc.lat = 0;
      cur_loc.lon = 0;
    }
    //location fetch
    function getLocation(){
      navigator.geolocation.getCurrentPosition(success, failure);
      console.log(cur_loc);
      return cur_loc;
    }
    getLocation();
    console.log(cur_loc.lat, cur_loc.lon);


    // Cesium Viewer Setup
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4ZjM0YTMzOC04NTIwLTQwMTItYTg5Ni0wOTFhNjlkZTJiYzIiLCJpZCI6MTUzNzcwLCJpYXQiOjE2ODkyNjg2NjV9.JHjxyoN8RovBonODf3w6B654ZNhxvoqCbAqAsKZrxBY'
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrain: Cesium.Terrain.fromWorldTerrain(),
    });  


    // Getting Data Over Time
    const data_readings = get_data_buffer();
    const len_data = Object.keys(data_readings).length - 1;
    console.log(data_readings['geodetic'])


    // Plotting data using databuffer 

    const start = Cesium.JulianDate.fromIso8601(data_readings[0].iso_string);
    const stop = Cesium.JulianDate.fromIso8601(data_readings[len_data-1].iso_string);
    
    const positionsOverTime = new Cesium.SampledPositionProperty();
    for (let i = 0; i<len_data; i++){
      const instance = data_readings[i];
      const time = Cesium.JulianDate.fromIso8601(instance.iso_string);
      const position = Cesium.Cartesian3.fromDegrees( instance.longitude,instance.latitude, instance.height*1000);
      positionsOverTime.addSample(time, position)
    }

    // Visualize the satellite with a dot and orbit.

    const orbit = viewer.entities.add({
      availability: new Cesium.TimeIntervalCollection([ new Cesium.TimeInterval({start: start, stop: stop}) ]),
      position: positionsOverTime,
      point: {pixelSize: 30, color: Cesium.Color.YELLOW },
      
    });

    const fixedPolyline = Cesium.Cartesian3.fromDegreesArrayHeights(data_readings['geodetic']);
    const redLine = viewer.entities.add({
      polyline: {
        // This callback updates positions each frame.
        positions: new Cesium.CallbackProperty(function (time, result) {
          var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
          var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
          if (Cesium.defined(icrfToFixed)) {
            let pos=[];
            for (let i = 0; i < fixedPolyline.length; i++) {
              let new_point = (Cesium.Matrix3.multiplyByVector(icrfToFixed, fixedPolyline[i], new Cesium.Cartesian3()));
              var cartographic = Cesium.Cartographic.fromCartesian(new_point);
              pos = pos.concat(Cesium.Math.toDegrees(cartographic.longitude), Cesium.Math.toDegrees(cartographic.latitude), cartographic.height);
            }
              // console.log(pos)
            return Cesium.Cartesian3.fromDegreesArrayHeights(pos,);
          }
        }, false),
        width: 2,
        material: new Cesium.PolylineGlowMaterialProperty({
          glowPower: 2,
          color: Cesium.Color.YELLOW,
        }),
      },
    });




    // fetching live data from server 
    const div_data = document.getElementById('data');
    const timeID = setInterval(get_live_data, 10000);
    console.log(cur_loc.lat)

    // Set the camera to follow the satellite 
    // viewer.trackedEntity = orbit; 

    let initialized = false;
    viewer.scene.globe.tileLoadProgressEvent.addEventListener(() => {
      if (!initialized && viewer.scene.globe.tilesLoaded === true) {
        viewer.clock.shouldAnimate = true;
        initialized = true;
        viewer.scene.camera.zoomOut(7000000);    // Wait for globe to load then zoom out 
      }
    });
    
    // setting camera to ICRF

    const scene = viewer.scene;
    const clock = viewer.clock;
    
    function icrf(scene, time) {
      if (scene.mode !== Cesium.SceneMode.SCENE3D) {return;}

      const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
      if (Cesium.defined(icrfToFixed)) {
        const camera = viewer.camera;
        const offset = Cesium.Cartesian3.clone(camera.position);
        const transform = Cesium.Matrix4.fromRotationTranslation(
          icrfToFixed
        );
        camera.lookAtTransform(transform, offset);
      }
    }

    function viewInICRF() {
      viewer.camera.flyHome(0);
      //clock.multiplier = 3 * 60;
      scene.postUpdate.addEventListener(icrf);

    }
    //viewInICRF();
    var location2 = {}
    const successCallback = (position) => {
      location2 = position.coords;
      //console.log(location);
    
    };
    
    const errorCallback = (error) => {
      console.log(error);
    };

    {% comment %} =============================================================== {% endcomment %}
    function drawOffNadirFootprint(satellite, instrument, timestamp){

      var satelliteName = satellite._id.split("/")[1]
    
      // get three points on the same plane
      var A = satellite.position.getValue(timestamp);
      var B = getGroundCartesian(A);
      var C = satellite.position.getValue({'dayNumber': timestamp.dayNumber, 'secondsOfDay': timestamp.secondsOfDay + 120.0});
    
      if (C === undefined) {
    
        return;
      }
      var origin = Cesium.Cartographic.fromCartesian(A);
      var destination = Cesium.Cartographic.fromCartesian(C);
      var direction = getHeading(origin, destination);
    
      // get two vectors on the plane using those points
      var AB = new Cesium.Cartesian3(B.x - A.x, B.y - A.y, B.z - A.z);
      var AC = new Cesium.Cartesian3(C.x - A.x, C.y - A.y, C.z - A.z);
    
    
      // get a vector normal to the plane
      var normal = new Cesium.Cartesian3();
      Cesium.Cartesian3.cross(AB, AC, normal);
    
    
    /*	if(direction == "South" && instrument.name != "SLSTR (Oblique)"){
        var newNormal = new Cesium.Cartesian3()
        newNormal = Cesium.Cartesian3.negate(normal, newNormal);
        normal = newNormal;
      }*/
    
      // get side of triangle opposite nadir angle
      // @HACK temporary solution to enable swath view for nadir satellites
      // @TODO The whole OPOT tool JS is an unholy mess needs massive cleaning and refactor
      var angleA = isNaN(instrument.off_nadir_angle) ? 0.5 : instrument.off_nadir_angle;
    
      var angleB = 90.0;
    
      var sideC = Cesium.Cartesian3.distance(A, B);
      var angleC = 180.0 - angleA - angleB;
      var sinC = sinDegrees(angleC);
      var sideB = sideC/sinC;
      var sideA = Math.sqrt((sideB * sideB) - (sideC * sideC));
    
      // get point perpendicular to satellite ground location, reassign it to C
      var ray = new Cesium.Ray(B, normal);
      C = Cesium.Ray.getPoint(ray, sideA);
    
      // get point on ground defining end of satellites viewing area
      var directionAC = new Cesium.Cartesian3();
      Cesium.Cartesian3.subtract(C, A, directionAC);
      var ray2 = new Cesium.Ray(A, directionAC);
      var intersection = Cesium.IntersectionTests.rayEllipsoid(ray2, viewer.scene.globe.ellipsoid);
      C = Cesium.Ray.getPoint(ray2, intersection.start);
    
      // TODO: Special case, only instruments which looks directly back
      // along direction of travel. Needs refactoring to use off_nadir_angle
      if(instrument.off_nadir_direction == 180.0 || instrument.off_nadir_direction == 0.0){
    
        //// get plane perpendicular to travel
    
        // get two vectors on the plane using those points
        var AB = new Cesium.Cartesian3(B.x - A.x, B.y - A.y, B.z - A.z);
        var AC = new Cesium.Cartesian3(C.x - A.x, C.y - A.y, C.z - A.z);
    
        // get a vector normal to the plane
        var normal = new Cesium.Cartesian3();
        Cesium.Cartesian3.cross(AB, AC, normal);
    
        if(instrument.off_nadir_direction == 0.0){
          var newNormal = new Cesium.Cartesian3()
          newNormal = Cesium.Cartesian3.negate(normal, newNormal);
          normal = newNormal;
        }
    
        // get side of triangle opposite nadir angle
        var angleA = instrument.off_nadir_angle; // off-nadir angle
        var angleB = 90.0;
    
        var sideC = Cesium.Cartesian3.distance(A, B);
        var angleC = 180.0 - angleA - angleB;
        var sinC = sinDegrees(angleC);
        var sideB = sideC/sinC;
        var sideA = Math.sqrt((sideB * sideB) - (sideC * sideC));
    
        // get point perpendicular to satellite ground location, reassign it to C
        var ray = new Cesium.Ray(B, normal);
        C = Cesium.Ray.getPoint(ray, sideA);
    
        // get point on ground defining end of satellites viewing area
        var directionAC = new Cesium.Cartesian3();
        Cesium.Cartesian3.subtract(C, A, directionAC);
        var ray2 = new Cesium.Ray(A, directionAC);
        var intersection = Cesium.IntersectionTests.rayEllipsoid(ray2, viewer.scene.globe.ellipsoid);
        C = Cesium.Ray.getPoint(ray2, intersection.start);
        //// get plane perpendicular satellite instrument line of site
    
        // get two vectors on the plane using those points
        var AB = new Cesium.Cartesian3(B.x - A.x, B.y - A.y, B.z - A.z);
        var AC = new Cesium.Cartesian3(C.x - A.x, C.y - A.y, C.z - A.z);
    
        // get a vector normal to the plane
        var normal = new Cesium.Cartesian3();
        Cesium.Cartesian3.cross(AB, AC, normal);
    
        var ray = new Cesium.Ray(C, normal);
        D = Cesium.Ray.getPoint(ray, instrument.swath_width/2.0);
        E = Cesium.Ray.getPoint(ray, -instrument.swath_width/2.0);
        D = getGroundCartesian(D);
        E = getGroundCartesian(E);
    
      }else{
        // Special case, only instrument whose line of sight points to the side of the swath, rather than the middle
          if(satelliteName == "AEOLUS"){
          // get point on ground defining start of satellties viewing area
            var geodesic1 = new Cesium.EllipsoidGeodesic(Cesium.Cartographic.fromCartesian(C), Cesium.Cartographic.fromCartesian(B));
            var newCartographic1 = geodesic1.interpolateUsingSurfaceDistance(instrument.swath_width);
            var D = Cesium.Cartesian3.fromDegrees(Cesium.Math.toDegrees(newCartographic1.longitude), Cesium.Math.toDegrees(newCartographic1.latitude))
          }else{
            var geodesic1 = new Cesium.EllipsoidGeodesic(Cesium.Cartographic.fromCartesian(B), Cesium.Cartographic.fromCartesian(C));
            var newCartographic1 = geodesic1.interpolateUsingSurfaceDistance(geodesic1.surfaceDistance + instrument.swath_width/2.0);
            var D = Cesium.Cartesian3.fromDegrees(Cesium.Math.toDegrees(newCartographic1.longitude), Cesium.Math.toDegrees(newCartographic1.latitude))
    
            var geodesic2 = new Cesium.EllipsoidGeodesic(Cesium.Cartographic.fromCartesian(C), Cesium.Cartographic.fromCartesian(B));
            var newCartographic2 = geodesic2.interpolateUsingSurfaceDistance(instrument.swath_width/2.0);
            var E = Cesium.Cartesian3.fromDegrees(Cesium.Math.toDegrees(newCartographic2.longitude), Cesium.Math.toDegrees(newCartographic2.latitude))
          }
    
      }
    
      var footPrintCollection = new Cesium.EntityCollection();
    
        var points;
      if(satelliteName == "AEOLUS"){
        points = [A, B, C, D];
    
        footPrintCollection.add(drawPoint(points[0], 'A', Cesium.Color.RED));
        footPrintCollection.add(drawPoint(points[2], 'A', Cesium.Color.RED));
        footPrintCollection.add(drawPoint(points[3], 'A', Cesium.Color.RED));
    
        footPrintCollection.add(drawLine(points[0], points[3], 'b', false));
        footPrintCollection.add(drawLine(points[0], points[2], 'b', false));
      }else{
        points = [A, B, C, D, E];
    
        footPrintCollection.add(drawPoint(points[0], 'A', Cesium.Color.RED));
        footPrintCollection.add(drawPoint(points[3], 'A', Cesium.Color.RED));
        footPrintCollection.add(drawPoint(points[4], 'A', Cesium.Color.RED));
    
        footPrintCollection.add(drawLine(points[0], points[3], 'b', false));
        footPrintCollection.add(drawLine(points[0], points[4], 'b', false));
      }
    
      if(previousPointsOffNadirPoints[satelliteName]){
        var polygon = drawOffNadirPolygon(previousPointsOffNadirPoints[satelliteName], points, satelliteName, true)
        footPrintCollection.add(polygon);
      }
      previousPointsOffNadirPoints[satelliteName] = points;
      return footPrintCollection;
    }
    
    {% comment %} ============================================================= {% endcomment %}
    
    

  </script>
 </div>
</body>
<style>
  
body{
  margin: 0px;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}
li{
  text-decoration: none;
  list-style: none;
}

h2{
  padding: 0px;
  margin: 0px;
  font-size: 40px;
}
.navbar{
  position: sticky;
  top: 0px;
  width: 100%;
}
.nav-list{
  display: flex;
  justify-content: right;
  text-align: center;
  vertical-align: center;
  padding: 20px 30px;
  margin: 0px;
  color: white;
  background-color: rgba(0,0,0,0.9);
  backdrop-filter: blur(15px);
  z-index: 10;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;

}

.nav-list li{
  padding: 1px 10px;
 
  text-decoration: none;
  list-style: none;
  vertical-align: center;
}
.logo{
  position: absolute;
  top: 2px;
  left: 14px;
}
.logo a{
  text-decoration: none;
  color: white;
}
#cesiumContainer{
  background-color: aquamarine;
  height: 400px;
  width: 75%;
  margin-top: 10px;
  margin-left: 10px;
}

.t1{
  position: relative;
  width: 400px;
  padding: 30px;
  font-size: 16px;
}
.main-block{
  display: flex;
  justify-content: left;

  
}
.sat-details{
  padding: 20px;
  margin-top: 10px;
  

}
.sat-name{
  font-size: 30px;
  font-weight: 700;
  padding: 20px 10px;
}
.description{
  padding: 10px
}
.t2{
  padding: 10px;
  font-size: 15px;
}
</style>
</html>